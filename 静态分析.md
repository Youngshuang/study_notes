# 静态分析

## Lecture7

- **Call Graph Construction**

  **CHA**：只考虑调用点的接收者类型，解目标方法（调用图：方法内的调用点——>调用方法）

  方法内的调用点取出，对每个调用点查找对应的目标方法，**增加这个调用点到目标方法的连线，将目标方法放进队列，同时放进一个已处理方法的map，遍历过的要跳过**。构造图的时候其实是种图遍历

- **Interprocedural Control-Flow Graph**

  ICFG = CFGs + **call & return edges**    使得方法内的CFG变成方法间的CFG，其实就是让CFG里的方法调用展开了，展开之后按之前的方法数据流分析！

  *控制流图就是基于这两个原则，分割代码基本块，代码指的是IR*

  1. *只能从块的第一条指令进入。*
  2. *只能从块的最后一条指令离开。*

  *然后数据量分析基于此开始，每个块内需要有transfer function（过程间则要Node+edge）表示抽象数据的状态跳转，块前需要不同格元素的meet/join，若是 join 函数，那么我们必然会从 lattice 的最小下界往上往safe走。而越往上走，我们就会失去更多的精确值。最小下界是在最底部，最小不动点在中间，最大上界在最上面*

- **ICFG画出来后，过程间数据流分析**

  call edge transfer需要传参。Return edge transfer返回返回值，所以并不是代码直接展开而是由transfer     做大梦操大心 跟上思路 专注学术的效率

  *常量传播就是带上这个常量key-value，算是带上了数据不仅是符号，且是值传递 引用传递再说*

  node transfer就是函数调用左手边的变量要删掉（其他和过程内的transfer一样），左手边变量可以 edge transfer返回。

  - 若不覆盖，在常量传播数据流分析的理论上，本来分支上的b和transfer返回的b  join后，值不一样会NaC 丢失精度。但是本来分支不能丢，不然那些常量都得在其他调用里保存一份数据

  - 本来不分析过程间调用，则函数调用处返回都粗暴用NAC，也是丢失大片精度
  - 那么引用传递呢？

## Lecture8

CHA,只看接受者的类型,所以如果是用接口或者抽象类,则会控制流里调用过多类型的实现函数,全都返回就会使常量分析精度下降NAC

- **指针分析也能建调用图**

  还是会分析完后比实际指向的更多

  变量和对象的指针关系,

  Pointer analysis: **which** objects a pointer can point to?

  Alias analysis: **can** two pointers point to the same object?

  编译优化,静态分析的基础

  四个要素,指针分析四个问题

- Heap Abstraction

  动态执行中，由于循环和递归的结构，堆上的对象数量可以是无限的。如果不做抽象，面对无限的对象，分析算法可能根本停不下来。解决方法也很简单，学校里同学太多了就分成班级来管理，我们也可以对堆上的对象进行抽象

  相关的技术有很多，这里只讲一个最常用的分支基于存储store-based   Allocation-Site Abstraction。而Storeless的方法本课程不涉及。

  几个new处理几个分析对象

- Context Sensitivity

  调用上下文记录的是函数调用前后相关变量的值。例如，参数和返回值是上下文的一部分。

- Flow Sensitivity

  对控制流分析,每个点维护一个指向流映射(数据流信息).所以每个语句都是流敏感,重视顺序

  ![image-20220918222247280](C:\Users\YOUNGSH\AppData\Roaming\Typora\typora-user-images\image-20220918222247280.png)

  每个语句位置记录一个变量和对象的map.忽略顺序就是整个程序只有一个map

**GIT**

本地创建文件后推上git.首先github需要建仓库,然后本地init, add commit  然后添加远程仓库关联`git remote add origin git@github.com:Youngshuang/study_notes.git`,

然后推送`git push -u origin master`将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。

若想删除暂存区`git rm -r --cached .`

若想删除远程关联`git remote remove origin `

1. 为什么要配置用户名和邮箱？

   因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址（名字和邮箱都不会进行验证），这样远程仓库才知道哪次提交是由谁完成的。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。

2. 配置的用户名和邮箱对push代码到远程仓库有什么影响？

   首先，配置的用户名和邮箱对push代码到远程仓库时的身份验证没有作用，即不用他们进行身份验证；他们仅仅会出现在远程仓库的commits里。

   其次，按正常操作来说，你应该配置你的真实用户名和邮箱，这样一来在远程仓库的commits里可以看到哪个操作是你所为。

   最后，这个用户名和邮箱是可以随便配置的（不提倡），如果你配置的邮箱是github里真实存在的邮箱，则commits里显示的是这个邮箱对应的账号；如果配置的邮箱是一个在github里不存在的邮箱，则commits里显示的是你配置的用户名。

3. 这只是commits,真正的鉴权是ssh和https做的

   远程仓库一般支持两种协议：SSH和HTTPS，SSH协议只认机器，HTTPS协议只认账号；也即为：如果使用SSH操作远程仓库的话，我们需要使用公钥和私钥对来做权限的认证，如果使用HTTPS操作远程仓库，则需要使用账号密码来做权限的认证。无论是公钥私钥对，还是账号密码，都只做权限的认证；但是远程仓库里需要记录这些提交记录是由谁来完成的；所以我们需要给本地的git设置用户名和邮箱，用于从本地仓库向远程仓库提交记录时，在远程仓库记录下这些操作是由谁来完成的。

4. 所以想要推到哪台机器,就是推之前remote add origin指定的

## Lecture9

