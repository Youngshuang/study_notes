# 静态分析

## Lecture7

- **Call Graph Construction**

  **CHA**：只考虑调用点的接收者类型，解目标方法（调用图：方法内的调用点——>调用方法）

  方法内的调用点取出，对每个调用点查找对应的目标方法，**增加这个调用点到目标方法的连线，将目标方法放进队列，同时放进一个已处理方法的map，遍历过的要跳过**。构造图的时候其实是种图遍历

- **Interprocedural Control-Flow Graph**

  ICFG = CFGs + **call & return edges**    使得方法内的CFG变成方法间的CFG，其实就是让CFG里的方法调用展开了，展开之后按之前的方法数据流分析！

  *控制流图就是基于这两个原则，分割代码基本块，代码指的是IR*

  1. *只能从块的第一条指令进入。*
  2. *只能从块的最后一条指令离开。*

  *然后数据量分析基于此开始，每个块内需要有transfer function（过程间则要Node+edge）表示抽象数据的状态跳转，块前需要不同格元素的meet/join，若是 join 函数，那么我们必然会从 lattice 的最小下界往上往safe走。而越往上走，我们就会失去更多的精确值。最小下界是在最底部，最小不动点在中间，最大上界在最上面*

- **ICFG画出来后，过程间数据流分析**

  call edge transfer需要传参。Return edge transfer返回返回值，所以并不是代码直接展开而是由transfer     做大梦操大心 跟上思路 专注学术的效率

  *常量传播就是带上这个常量key-value，算是带上了数据不仅是符号，且是值传递 引用传递再说*

  node transfer就是函数调用左手边的变量要删掉（其他和过程内的transfer一样），左手边变量可以 edge transfer返回。

  - 若不覆盖，在常量传播数据流分析的理论上，本来分支上的b和transfer返回的b  join后，值不一样会NaC 丢失精度。但是本来分支不能丢，不然那些常量都得在其他调用里保存一份数据

  - 本来不分析过程间调用，则函数调用处返回都粗暴用NAC，也是丢失大片精度
  - 那么引用传递呢？

## Lecture8

CHA,只看接受者的类型,所以如果是用接口或者抽象类,则会控制流里调用过多类型的实现函数,全都返回就会使常量分析精度下降NAC

- **指针分析也能建调用图**

  还是会分析完后比实际指向的更多

  变量和对象的指针关系,

  Pointer analysis: **which** objects a pointer can point to?

  Alias analysis: **can** two pointers point to the same object?

  编译优化,静态分析的基础

  四个要素,指针分析四个问题

- Heap Abstraction

  动态执行中，由于循环和递归的结构，堆上的对象数量可以是无限的。如果不做抽象，面对无限的对象，分析算法可能根本停不下来。解决方法也很简单，学校里同学太多了就分成班级来管理，我们也可以对堆上的对象进行抽象

  相关的技术有很多，这里只讲一个最常用的分支基于存储store-based   Allocation-Site Abstraction。而Storeless的方法本课程不涉及。

  几个new处理几个分析对象

- Context Sensitivity

  调用上下文记录的是函数调用前后相关变量的值。例如，参数和返回值是上下文的一部分。

- Flow Sensitivity

  对控制流分析,每个点维护一个指向流映射(数据流信息).所以每个语句都是流敏感,重视顺序

  ![image-20220918222247280](C:\Users\YOUNGSH\AppData\Roaming\Typora\typora-user-images\image-20220918222247280.png)

  每个语句位置记录一个变量和对象的map.忽略顺序就是整个程序只有一个map

